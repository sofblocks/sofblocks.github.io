---
layout: single
title: "Azure Cloud Pentesting"
permalink: /azure-cloud-pentesting/
toc: true
tags: [Azure, Pentesting, Service Principal, Privileges Escalation, Authentication]
header: 
    header:  "assets/imgs/notes/azurepen.jpg"
    teaser: "assets/imgs/notes/azurepen.jpg"
    og_image: "assets/imgs/notes/azurepen.jpg"
---

The rise of cloud computing has seen many companies shifting their attention to adopting cloud services such as storage, network, database, and software applications among others.

This particular technology adoption has allowed companies to improve customer experience, increase productivity, lower costs and improve business continuity. While there are many advantages to cloud computing there are also disadvantages to it.

One of the major issues is, it has provided an avenue of attack for cybercriminals mainly because of how organizations are using, storing, and sharing information.

The number of attacks on cloud platforms has increased rapidly in recent years and since cloud computing is here to stay organizations need to know how to prevent themselves from these attacks.

It starts with cloud customers understanding the shared responsibility model offered by their cloud provider. There should be a fine line between what security tasks the customer is expected to handle and what the cloud provider handles. Microsoft clearly states that the customer is responsible for protecting the security of their data and identities, on-premises resources, and the cloud components they control. 

Therefore, users have a responsibility to maintain their cloud tenant security by performing regular security audits and assessments. The security assessment process can be complex and proper protocols have to be followed to keep other clients from becoming affected by these planned tests.

All cloud providers have a clear policy of what is permitted when it comes to performing security assessments on customer environments. For Microsoft, the rules of engagement are detailed [here.](https://www.microsoft.com/en-us/msrc/pentest-rules-of-engagement)

Some of its products permitted for pentest in the Azure environment include:

 Azure AD tenant configurations, Microsoft Intune, Office 365, and Azure DevOps among others.

In this blog post, we will be focusing on Azure AD security assessment, particularly on the applications that have been registered in Azure AD tenant. Developers register these applications so as to delegate identity and access management functions to Azure AD.

As a security engineer, you may be tasked with enumerating excessive privileges that may allow potential internal Azure users, especially developers to take over the Azure environment.  

These privileged identities are normally targeted by Cyber attackers through credentials theft attacks and other means so as to gain access to sensitive data.

We are going to look at how to perform an Azure AD security assessment to locate these privileged identities, but first, let us familiarize ourselves with some of the Microsoft Azure environment terms.

**Azure Tenant -** An instance of Azure AD. This tenant can represent a single identity (person, company, or organization) and can own one or several subscriptions.

**Role** - A role is made up of a name and a set of operations that can be performed, such as read, write, and delete. Azure controls access to resources using two main systems, RBAC and Azure AD roles.  Azure role-based access control (Azure RBAC), controls access to Azure resources such as virtual machines or storage using Azure Resource Management while Azure AD roles control access to Azure AD resources such as users, groups, and applications using the Microsoft Graph API.

**Azure app registration** - Represent an application that is being created in the tenant. when you register an app in Azure AD two objects are created.

1. **Application object** which is the global definition of the application, you can call it a blueprint.
2. **Service principal** which is the local instantiation of the application. This is the object that will be managing the app. Whenever the app wants to authenticate to Azure AD and access Azure resources it will do so using this service principal object.   

**Enterprise application** - Basically, represents a list of service principals registered in the tenant. 

**Microsoft Graph -** is a RESTful web API that enables you to access Microsoft Cloud service resources. Applications and service principals can authenticate to Microsoft and gain access to the API using:

- Secretes - passwords
- Certificates

 **Scope**: These are permissions for a given resource that represent what a client application can access on behalf of the user.

The Microsoft Graph has two categories of permissions: **application permissions and delegated permissions**. Application permissions allow an app to act as any user, while delegated permissions are used by **apps that have a signed-in user present**.

### Recon:

Let us start our reconnaissance process. As a security engineer,  you will authenticate as any Azure AD user in the subject tenant using Powershell.  We will be using the PowerShell AZureAD module.

The module can be installed on any machine with the following command.

```powershell
Install-Module -Name AzureAD  -Force
```

Connect to Azure tenant any user account’s credentials.

```powershell
connect-AzureAD
```

Enter the credentials on the Microsoft sign-in window that pops up.

### Enumerating Users roles

Once we have logged in to the tenant, will start by listing roles that have been activated and assigned to users. We will use a PowerShell cmdlet called Get-AzureADDirectoryRole.  Note that the roles we are enumerating here are Azure AD roles and not Azure RBAC roles. 

![upload-image]({{ "/assets/imgs/notes/rolesenum.png" | relative_url }})

From the screenshot above we can see that the roles Application and Privilege role admins have been activated in the tenant which means one or more azure Ad users might have been assigned these roles. Also, we have a global admin role that has been assigned to one or more azure ad users. 

Users with an Application admin role can create and manage all aspects of enterprise applications, application registrations, and application proxy settings.

Privileged Role Administrator, Can manage role assignments in Azure AD, and all aspects of Privileged Identity Management.

Global administrator – the highest level of access, including the ability to grant administrator access to other users and to reset other administrators’ passwords.

### Enumerating the Application Administrators role

Let us enumerate any Azure AD users assigned to the Application Administrators role.

Application Administrators can reset credentials or client secrets for any application Service Principal in an Azure AD tenant this means it holds special privileges that open up specific privilege escalation attack primitives using Service Principals.

From the previous command we have run, we will grab the object ID of the application administrator role

To search for any users assigned to this role we will run the Get-AzureADDirectoryRoleMember cmdlet and then filter the results on the -ObjectId

```powershell
objectID: "47042d90-3a98-43d8-86f4-f1a00b62f213"
```

![upload-image]({{ "/assets/imgs/notes/appadmin.png" | relative_url }})

We get one  Azure AD user assigned to the Application Administrator role.

Save the User principal name in a variable called appadmin_username

### Enumerating Privilege Role Administrators

Next, let us enumerate users/objects that have been assigned the role of a Privilege Role Administrator.

![upload-image]({{ "/assets/imgs/notes/pradmin.png" | relative_url }})

The object Id is for the service principal (Identity) which has been assigned to an application of the given AppId

Take note of the AppID

```powershell
#appid:aba1c3d0-e5f0-409d-abbc-9b07f4d61528 
```

Lets find the Object ID for the application that is being represented by the above service principal. We will use the Get-AzureADApplication cmdlet and filter the results based on the appId captured above.

![upload-image]({{ "/assets/imgs/notes/obid.png" | relative_url }})

Take note of the objectID:

```powershell
#AppID: aba1c3d0-e5f0-409d-abbc-9b07f4d61528 
#ObjectID: ce61d8bd-98f0-45f5-87d7-c28abc6d8f3d
```

This is the object ID  that shows in the Azure portal under Azure Active Directory → App registrations.

![upload-image]({{ "/assets/imgs/notes/obappid.png" | relative_url }})

### Enumerating Global Administrator target application

We can also try to enumerate the target Azure AD applications assigned to a Global Administrator role. Attackers may decide to attack an application directly that holds the Global Administrator role and use it to elevate their privileges to Global Administrator. 

Again we use the Get-AzureADDirectoryRole cmdlet to list out the activated roles.  We then filter he results based on a Display Name of Global administrator. The purpose of all this is to grab the ObjectId.

![upload-image]({{ "/assets/imgs/notes/gad.png" | relative_url }})

We captured the object id and stored it in a variable called gaObjectId.

Next, we use the object ID captured above to list objects assigned into the role of Global administrator.

![upload-image]({{ "/assets/imgs/notes/gbob.png" | relative_url }})

From the results, we can see that we have two service principals of some applications in the tenant that have been assigned the role of Global administrator.

Next, we grab the application ID of one of the service principals listed above (Marketing-App) and locate the application’s Object ID. Similar to what we did when we were enumerating the privileged role administrator.

![upload-image]({{ "/assets/imgs/notes/gapid.png" | relative_url }})

Note down the  objectID fo the application.:

```powershell
#AppID: 4c89cba2-81f6-47d0-95cc-81537ad1ca6b
#OjectID: c1e9a458-dfb7-4892-9ad7-9194cc6c183f
```

Disconnect from Azure AD using the powershell cmdlet, Disconnect-AzureAD.
```powershell
Disconnect-AzureAD
```

### Logging in as an Application Administrator and generating a new client secret for PRA target:

In this section, we will authenticate as the Application Administrator and then generate a new client secret for the Service Principal(Identity) which has the Privileged Role Administrator role. To authenticate as the Application Administrator,  we will use the username that was already gathered in prior phases and a password that might have been obtained through one of the many password-stealing techniques.

We’ll store the username and password in variables called appadmin_username and appadmin_password respectively and then run the Connect-AzureAD cmdlet to login to Azure as an Application Administrator.

```powershell
# Connect with the Azure AD user assigned to Application Administrator role
$appadmin_username = "mistyjohnson@finemuziqgmail.onmicrosoft.com"
$appadmin_password = "keen-pika-22BX"
```

![upload-image]({{ "/assets/imgs/notes/connectad.png" | relative_url }})

Next we use the **New-AzureADApplicationPasswordCredential** to generate a new application client secret against the target. To run the command we will need the ObjectId of the application whose Service Principal has the Privileged Role Administrator and which we had already obtained from prior phases.

```powershell
# AppID and ObjectID

#AppID: aba1c3d0-e5f0-409d-abbc-9b07f4d61528 
#ObjectID: ce61d8bd-98f0-45f5-87d7-c28abc6d8f3d
#Note this is ObjectID of the app registration not of the service principal.

# Set the AppId of the target PRA's app registration
$azureApplicationId = "aba1c3d0-e5f0-409d-abbc-9b07f4d61528"

# Set the objectID of the target PRA's app registration
$targetObjectId = "ce61d8bd-98f0-45f5-87d7-c28abc6d8f3d"
```

Note that when an App Registration has an associated Service Principal in Azure, the Service Principal will have a unique Object ID and an Application ID that matches the Application ID of the App Registration.

```powershell
# Generate a new client secret for the app registration target
# Creates a password credential for an application.
$AppKeyCred = New-AzureADApplicationPasswordCredential -ObjectId $targetObjectId 
$AppKeyCred
```

Get the new client secret's plaintext password by setting it to a variable with $AppKeyCred.value. We’ll use this variable soon to authenticate as the Service Principal using this generated client secret.

![upload-image]({{ "/assets/imgs/notes/secretv.png" | relative_url }})

```powershell
# RkE+f0bvIsX/qd6ce9H7TBluR7BFtDxJ3HpoppSV/gs=
```

Before we disconnect lets obtained a tennat objectId that we are going to use in the next step.

We are going to use the command below and store the results in a variable calle tenantId

```powershell
$tenantId = (Get-AzureADTenantDetail).ObjectId
# 670a2dbd-65a8-43b3-89d4-05e1080d1afa
```

Now we disconnect from Azure AD as the Application Administrator.
```powershell
Disconnect-AzureAD
```